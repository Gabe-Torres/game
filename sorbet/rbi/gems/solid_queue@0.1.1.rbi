# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solid_queue` gem.
# Please instead update this file by running `bin/tapioca gem solid_queue`.

# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#3
module ActiveJob
  class << self
    # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#7
    def adapter_name(adapter); end

    # source://activejob/7.1.2/lib/active_job/deprecator.rb#4
    def deprecator; end

    # source://activejob/7.1.2/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/7.1.2/lib/active_job/enqueuing.rb#16
    def perform_all_later(*jobs); end

    # source://activejob/7.1.2/lib/active_job.rb#53
    def use_big_decimal_serializer; end

    # source://activejob/7.1.2/lib/active_job.rb#53
    def use_big_decimal_serializer=(_arg0); end

    # source://activejob/7.1.2/lib/active_job.rb#61
    def verbose_enqueue_logs; end

    # source://activejob/7.1.2/lib/active_job.rb#61
    def verbose_enqueue_logs=(_arg0); end

    # source://activejob/7.1.2/lib/active_job/version.rb#7
    def version; end

    private

    # source://activejob/7.1.2/lib/active_job/instrumentation.rb#6
    def instrument_enqueue_all(queue_adapter, jobs); end
  end
end

class ActiveJob::Base
  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#963
  def _enqueue_callbacks; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#963
  def _perform_callbacks; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#951
  def _run_enqueue_callbacks(&block); end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#951
  def _run_perform_callbacks(&block); end

  # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
  def after_discard_procs; end

  # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
  def after_discard_procs=(_arg0); end

  # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
  def after_discard_procs?; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration?; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit?; end

  # source://activejob/7.1.2/lib/active_job/logging.rb#11
  def logger; end

  # source://activejob/7.1.2/lib/active_job/logging.rb#11
  def logger=(val); end

  # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#26
  def queue_adapter(&block); end

  # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
  def queue_name_prefix; end

  # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
  def queue_name_prefix=(_arg0); end

  # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
  def queue_name_prefix?; end

  # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
  def rescue_handlers; end

  # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
  def rescue_handlers?; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#955
    def _enqueue_callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#959
    def _enqueue_callbacks=(value); end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#955
    def _perform_callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#959
    def _perform_callbacks=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#24
    def _queue_adapter; end

    # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#24
    def _queue_adapter=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#23
    def _queue_adapter_name; end

    # source://activejob/7.1.2/lib/active_job/queue_adapter.rb#23
    def _queue_adapter_name=(value); end

    # source://activejob/7.1.2/lib/active_job/test_helper.rb#19
    def _test_adapter; end

    # source://activejob/7.1.2/lib/active_job/test_helper.rb#19
    def _test_adapter=(value); end

    # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
    def after_discard_procs; end

    # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
    def after_discard_procs=(value); end

    # source://activejob/7.1.2/lib/active_job/exceptions.rb#12
    def after_discard_procs?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit?; end

    # source://activejob/7.1.2/lib/active_job/logging.rb#12
    def log_arguments; end

    # source://activejob/7.1.2/lib/active_job/logging.rb#12
    def log_arguments=(value); end

    # source://activejob/7.1.2/lib/active_job/logging.rb#12
    def log_arguments?; end

    # source://activejob/7.1.2/lib/active_job/logging.rb#11
    def logger; end

    # source://activejob/7.1.2/lib/active_job/logging.rb#11
    def logger=(val); end

    # source://activejob/7.1.2/lib/active_job/queue_priority.rb#49
    def priority; end

    # source://activejob/7.1.2/lib/active_job/queue_priority.rb#49
    def priority=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_priority.rb#49
    def priority?; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#55
    def queue_name; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#55
    def queue_name=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#55
    def queue_name?; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#56
    def queue_name_delimiter; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#56
    def queue_name_delimiter=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#56
    def queue_name_delimiter?; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
    def queue_name_prefix; end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
    def queue_name_prefix=(value); end

    # source://activejob/7.1.2/lib/active_job/queue_name.rb#57
    def queue_name_prefix?; end

    # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
    def rescue_handlers; end

    # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
    def rescue_handlers=(value); end

    # source://activesupport/7.1.2/lib/active_support/rescuable.rb#15
    def rescue_handlers?; end

    # source://activejob/7.1.2/lib/active_job/exceptions.rb#11
    def retry_jitter; end

    # source://activejob/7.1.2/lib/active_job/exceptions.rb#11
    def retry_jitter=(value); end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#4
module ActiveJob::ConcurrencyControls
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveJob::ConcurrencyControls::ClassMethods

  # source://solid_queue//lib/active_job/concurrency_controls.rb#26
  def concurrency_key; end

  private

  # source://solid_queue//lib/active_job/concurrency_controls.rb#44
  def compute_concurrency_parameter(option); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#40
  def concurrency_group; end

  module GeneratedClassMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_group; end
    def concurrency_group=(value); end
    def concurrency_group?; end
    def concurrency_key; end
    def concurrency_key=(value); end
    def concurrency_key?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end

  module GeneratedInstanceMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#0
module ActiveJob::ConcurrencyControls::ClassMethods
  # source://solid_queue//lib/active_job/concurrency_controls.rb#18
  def limits_concurrency(key:, to: T.unsafe(nil), group: T.unsafe(nil), duration: T.unsafe(nil)); end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#7
ActiveJob::ConcurrencyControls::DEFAULT_CONCURRENCY_GROUP = T.let(T.unsafe(nil), Proc)

# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#4
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/7.1.2/lib/active_job/queue_adapters.rb#137
    def lookup(name); end
  end
end

# == Active Job SolidQueue adapter
#
# To use it set the queue_adapter config to +:solid_queue+.
#
#   Rails.application.config.active_job.queue_adapter = :solid_queue
#
# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#10
class ActiveJob::QueueAdapters::SolidQueueAdapter
  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#11
  def enqueue(active_job); end

  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#17
  def enqueue_at(active_job, timestamp); end
end

# source://solid_queue//lib/solid_queue/version.rb#1
module SolidQueue
  # source://solid_queue//lib/solid_queue.rb#27
  def app_executor; end

  # source://solid_queue//lib/solid_queue.rb#27
  def app_executor=(val); end

  # source://solid_queue//lib/solid_queue.rb#42
  def clear_finished_jobs_after; end

  # source://solid_queue//lib/solid_queue.rb#42
  def clear_finished_jobs_after=(val); end

  # source://solid_queue//lib/solid_queue.rb#27
  def connects_to; end

  # source://solid_queue//lib/solid_queue.rb#27
  def connects_to=(val); end

  # source://solid_queue//lib/solid_queue.rb#43
  def default_concurrency_control_period; end

  # source://solid_queue//lib/solid_queue.rb#43
  def default_concurrency_control_period=(val); end

  # source://solid_queue//lib/solid_queue.rb#26
  def logger; end

  # source://solid_queue//lib/solid_queue.rb#26
  def logger=(val); end

  # source://solid_queue//lib/solid_queue.rb#27
  def on_thread_error; end

  # source://solid_queue//lib/solid_queue.rb#27
  def on_thread_error=(val); end

  # source://solid_queue//lib/solid_queue.rb#41
  def preserve_finished_jobs; end

  # source://solid_queue//lib/solid_queue.rb#41
  def preserve_finished_jobs=(val); end

  # source://solid_queue//lib/solid_queue.rb#32
  def process_alive_threshold; end

  # source://solid_queue//lib/solid_queue.rb#32
  def process_alive_threshold=(val); end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_heartbeat_interval; end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_heartbeat_interval=(val); end

  # source://solid_queue//lib/solid_queue.rb#34
  def shutdown_timeout; end

  # source://solid_queue//lib/solid_queue.rb#34
  def shutdown_timeout=(val); end

  # source://solid_queue//lib/solid_queue.rb#36
  def silence_polling; end

  # source://solid_queue//lib/solid_queue.rb#36
  def silence_polling=(val); end

  # source://solid_queue//lib/solid_queue.rb#39
  def supervisor; end

  # source://solid_queue//lib/solid_queue.rb#39
  def supervisor=(val); end

  # source://solid_queue//lib/solid_queue.rb#38
  def supervisor_pidfile; end

  # source://solid_queue//lib/solid_queue.rb#38
  def supervisor_pidfile=(val); end

  # source://solid_queue//lib/solid_queue.rb#29
  def use_skip_locked; end

  # source://solid_queue//lib/solid_queue.rb#29
  def use_skip_locked=(val); end

  class << self
    # source://solid_queue//lib/solid_queue.rb#27
    def app_executor; end

    # source://solid_queue//lib/solid_queue.rb#27
    def app_executor=(val); end

    # source://solid_queue//lib/solid_queue.rb#42
    def clear_finished_jobs_after; end

    # source://solid_queue//lib/solid_queue.rb#42
    def clear_finished_jobs_after=(val); end

    # source://solid_queue//lib/solid_queue.rb#27
    def connects_to; end

    # source://solid_queue//lib/solid_queue.rb#27
    def connects_to=(val); end

    # source://solid_queue//lib/solid_queue.rb#43
    def default_concurrency_control_period; end

    # source://solid_queue//lib/solid_queue.rb#43
    def default_concurrency_control_period=(val); end

    # source://solid_queue//lib/solid_queue.rb#26
    def logger; end

    # source://solid_queue//lib/solid_queue.rb#26
    def logger=(val); end

    # source://solid_queue//lib/solid_queue.rb#27
    def on_thread_error; end

    # source://solid_queue//lib/solid_queue.rb#27
    def on_thread_error=(val); end

    # source://solid_queue//lib/solid_queue.rb#41
    def preserve_finished_jobs; end

    # source://solid_queue//lib/solid_queue.rb#41
    def preserve_finished_jobs=(val); end

    # source://solid_queue//lib/solid_queue.rb#32
    def process_alive_threshold; end

    # source://solid_queue//lib/solid_queue.rb#32
    def process_alive_threshold=(val); end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_heartbeat_interval; end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_heartbeat_interval=(val); end

    # source://railties/7.1.2/lib/rails/engine.rb#405
    def railtie_helpers_paths; end

    # source://railties/7.1.2/lib/rails/engine.rb#394
    def railtie_namespace; end

    # source://railties/7.1.2/lib/rails/engine.rb#409
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://solid_queue//lib/solid_queue.rb#34
    def shutdown_timeout; end

    # source://solid_queue//lib/solid_queue.rb#34
    def shutdown_timeout=(val); end

    # source://solid_queue//lib/solid_queue.rb#36
    def silence_polling; end

    # source://solid_queue//lib/solid_queue.rb#36
    def silence_polling=(val); end

    # @return [Boolean]
    #
    # source://solid_queue//lib/solid_queue.rb#49
    def silence_polling?; end

    # source://solid_queue//lib/solid_queue.rb#39
    def supervisor; end

    # source://solid_queue//lib/solid_queue.rb#39
    def supervisor=(val); end

    # @return [Boolean]
    #
    # source://solid_queue//lib/solid_queue.rb#45
    def supervisor?; end

    # source://solid_queue//lib/solid_queue.rb#38
    def supervisor_pidfile; end

    # source://solid_queue//lib/solid_queue.rb#38
    def supervisor_pidfile=(val); end

    # source://railties/7.1.2/lib/rails/engine.rb#397
    def table_name_prefix; end

    # source://railties/7.1.2/lib/rails/engine.rb#401
    def use_relative_model_naming?; end

    # source://solid_queue//lib/solid_queue.rb#29
    def use_skip_locked; end

    # source://solid_queue//lib/solid_queue.rb#29
    def use_skip_locked=(val); end
  end
end

# source://solid_queue//lib/solid_queue/app_executor.rb#4
module SolidQueue::AppExecutor
  # source://solid_queue//lib/solid_queue/app_executor.rb#13
  def handle_thread_error(error); end

  # source://solid_queue//lib/solid_queue/app_executor.rb#5
  def wrap_in_app_executor(&block); end
end

class SolidQueue::BlockedExecution < ::SolidQueue::Execution
  include ::SolidQueue::BlockedExecution::GeneratedAttributeMethods
  include ::SolidQueue::BlockedExecution::GeneratedAssociationMethods

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_semaphore(*args); end

  def release; end

  private

  def acquire_concurrency_lock; end
  def promote_to_ready; end
  def ready_attributes; end
  def set_expires_at; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.2/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def release_many(concurrency_keys); end
    def release_one(concurrency_key); end
    def unblock(count); end

    private

    def releasable(concurrency_keys); end
  end
end

module SolidQueue::BlockedExecution::GeneratedAssociationMethods
  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_semaphore(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_semaphore(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_semaphore!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_semaphore; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_semaphore; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def semaphore; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def semaphore=(value); end
end

module SolidQueue::BlockedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution < ::SolidQueue::Execution
  include ::SolidQueue::ClaimedExecution::GeneratedAttributeMethods
  include ::SolidQueue::ClaimedExecution::GeneratedAssociationMethods

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_process(*args); end

  def perform; end
  def release; end

  private

  def execute; end
  def failed_with(error); end
  def finished; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.2/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    def claiming(job_ids, process_id, &block); end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    def release_all; end
  end
end

module SolidQueue::ClaimedExecution::GeneratedAssociationMethods
  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_process(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_process(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_process!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def process; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def process=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#145
  def process_changed?; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#149
  def process_previously_changed?; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_process; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_process; end
end

module SolidQueue::ClaimedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution::Result < ::Struct
  def success?; end
end

# source://solid_queue//lib/solid_queue/configuration.rb#4
class SolidQueue::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#18
  def initialize(mode: T.unsafe(nil), load_from: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/configuration.rb#43
  def dispatchers; end

  # source://solid_queue//lib/solid_queue/configuration.rb#51
  def max_number_of_threads; end

  # source://solid_queue//lib/solid_queue/configuration.rb#23
  def processes; end

  # source://solid_queue//lib/solid_queue/configuration.rb#32
  def workers; end

  private

  # source://solid_queue//lib/solid_queue/configuration.rb#61
  def config_from(file_or_hash, env: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/configuration.rb#94
  def default_config_file; end

  # source://solid_queue//lib/solid_queue/configuration.rb#71
  def dispatchers_options; end

  # source://solid_queue//lib/solid_queue/configuration.rb#86
  def load_config_file(file); end

  # source://solid_queue//lib/solid_queue/configuration.rb#76
  def load_config_from(file_or_hash); end

  # Returns the value of attribute mode.
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#57
  def mode; end

  # Returns the value of attribute raw_config.
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#57
  def raw_config; end

  # source://solid_queue//lib/solid_queue/configuration.rb#66
  def workers_options; end
end

# source://solid_queue//lib/solid_queue/configuration.rb#59
SolidQueue::Configuration::DEFAULT_CONFIG_FILE_PATH = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/configuration.rb#12
SolidQueue::Configuration::DISPATCHER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue/configuration.rb#5
SolidQueue::Configuration::WORKER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue/dispatcher.rb#4
class SolidQueue::Dispatcher < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Poller
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable

  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#12
  def initialize(**options); end

  # Returns the value of attribute batch_size.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def batch_size; end

  # Sets the attribute batch_size
  #
  # @param value the value to set the attribute batch_size to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def batch_size=(_arg0); end

  # Returns the value of attribute concurrency_maintenance_interval.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def concurrency_maintenance_interval; end

  # Sets the attribute concurrency_maintenance_interval
  #
  # @param value the value to set the attribute concurrency_maintenance_interval to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def concurrency_maintenance_interval=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#8
  def polling_interval; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#8
  def polling_interval=(_arg0); end

  private

  # source://solid_queue//lib/solid_queue/dispatcher.rb#30
  def dispatch_next_batch; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#53
  def expire_semaphores; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#65
  def initial_jitter; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#36
  def launch_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#69
  def metadata; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#21
  def run; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#49
  def stop_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#59
  def unblock_blocked_executions; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://solid_queue//lib/solid_queue/engine.rb#4
class SolidQueue::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

class SolidQueue::Execution < ::SolidQueue::Record
  include ::SolidQueue::Execution::GeneratedAttributeMethods
  include ::SolidQueue::Execution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::JobAttributes
  extend ::SolidQueue::Execution::JobAttributes::ClassMethods

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_job(*args); end

  # source://activerecord/7.1.2/lib/active_record/transactions.rb#304
  def discard; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.2/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end
  end
end

module SolidQueue::Execution::GeneratedAssociationMethods
  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_job(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_job(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_job!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def job; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def job=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#145
  def job_changed?; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#149
  def job_previously_changed?; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_job; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_job; end
end

module SolidQueue::Execution::GeneratedAttributeMethods; end

module SolidQueue::Execution::JobAttributes
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Execution::JobAttributes::ClassMethods

  private

  def assume_attributes_from_job(attributes); end
end

SolidQueue::Execution::JobAttributes::ASSUMIBLE_ATTRIBUTES_FROM_JOB = T.let(T.unsafe(nil), Array)

module SolidQueue::Execution::JobAttributes::ClassMethods
  def assume_attributes_from_job(*attributes); end
end

class SolidQueue::FailedExecution < ::SolidQueue::Execution
  include ::SolidQueue::FailedExecution::GeneratedAttributeMethods
  include ::SolidQueue::FailedExecution::GeneratedAssociationMethods

  def backtrace; end
  def exception; end
  def exception=(_arg0); end
  def exception_class; end
  def message; end
  def retry; end

  private

  def expand_error_details_from_exception; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end
  end
end

module SolidQueue::FailedExecution::GeneratedAssociationMethods; end
module SolidQueue::FailedExecution::GeneratedAttributeMethods; end

class SolidQueue::Job < ::SolidQueue::Record
  include ::SolidQueue::Job::GeneratedAttributeMethods
  include ::SolidQueue::Job::GeneratedAssociationMethods
  include ::SolidQueue::Job::Executable
  include ::SolidQueue::Job::ConcurrencyControls
  include ::SolidQueue::Job::Clearable
  extend ::SolidQueue::Job::Clearable::ClassMethods

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_blocked_execution(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_claimed_execution(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_failed_execution(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_ready_execution(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_scheduled_execution(*args); end

  def concurrency_duration(*_arg0, **_arg1, &_arg2); end
  def concurrency_limit(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.2/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def clearable(*args, **_arg1); end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    def enqueue(**kwargs); end
    def enqueue_active_job(active_job, scheduled_at: T.unsafe(nil)); end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    private

    def defaults; end
  end
end

module SolidQueue::Job::Clearable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::Clearable::ClassMethods
end

module SolidQueue::Job::Clearable::ClassMethods
  def clear_finished_in_batches(batch_size: T.unsafe(nil), finished_before: T.unsafe(nil)); end
end

module SolidQueue::Job::ConcurrencyControls
  extend ::ActiveSupport::Concern

  def concurrency_limited?; end
  def unblock_next_blocked_job; end

  private

  def acquire_concurrency_lock; end
  def block; end
  def job_class; end
  def release_concurrency_lock; end
  def release_next_blocked_job; end
end

SolidQueue::Job::DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)
SolidQueue::Job::DEFAULT_QUEUE_NAME = T.let(T.unsafe(nil), String)

module SolidQueue::Job::Executable
  extend ::ActiveSupport::Concern

  def claimed?; end
  def discard; end
  def dispatch; end
  def failed?; end
  def failed_with(exception); end
  def finished!; end
  def finished?; end
  def prepare_for_execution; end
  def ready?; end
  def retry; end
  def scheduled?; end

  private

  def due?; end
  def preserve_finished_jobs?; end
  def ready; end
  def schedule; end
end

module SolidQueue::Job::GeneratedAssociationMethods
  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def blocked_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def blocked_execution=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_blocked_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_claimed_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_failed_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_ready_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_scheduled_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def claimed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def claimed_execution=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_blocked_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_blocked_execution!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_claimed_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_claimed_execution!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_failed_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_failed_execution!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_ready_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_ready_execution!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_scheduled_execution(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_scheduled_execution!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def failed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def failed_execution=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def ready_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def ready_execution=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_blocked_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_claimed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_failed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_ready_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_scheduled_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_blocked_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_claimed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_failed_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_ready_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_scheduled_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def scheduled_execution; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def scheduled_execution=(value); end
end

module SolidQueue::Job::GeneratedAttributeMethods; end

class SolidQueue::Pause < ::SolidQueue::Record
  include ::SolidQueue::Pause::GeneratedAttributeMethods
  include ::SolidQueue::Pause::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end
  end
end

module SolidQueue::Pause::GeneratedAssociationMethods; end
module SolidQueue::Pause::GeneratedAttributeMethods; end

# source://solid_queue//lib/solid_queue/pool.rb#4
class SolidQueue::Pool
  include ::SolidQueue::AppExecutor

  # @return [Pool] a new instance of Pool
  #
  # source://solid_queue//lib/solid_queue/pool.rb#11
  def initialize(size, on_idle: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/pool.rb#41
  def idle?; end

  # source://solid_queue//lib/solid_queue/pool.rb#37
  def idle_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#18
  def post(execution); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown(*_arg0, **_arg1, &_arg2); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute size.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#7
  def size; end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def wait_for_termination(*_arg0, **_arg1, &_arg2); end

  private

  # Returns the value of attribute available_threads.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def available_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#54
  def executor; end

  # Returns the value of attribute mutex.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def mutex; end

  # Returns the value of attribute on_idle.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def on_idle; end
end

# source://solid_queue//lib/solid_queue/pool.rb#48
SolidQueue::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class SolidQueue::Process < ::SolidQueue::Record
  include ::SolidQueue::Process::GeneratedAttributeMethods
  include ::SolidQueue::Process::GeneratedAssociationMethods
  include ::SolidQueue::Process::Prunable
  extend ::SolidQueue::Process::Prunable::ClassMethods

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_claimed_executions(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_forks(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_supervisor(*args); end

  def deregister; end
  def heartbeat; end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_claimed_executions(*args); end

  # source://activerecord/7.1.2/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_forks(*args); end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.2/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def prunable(*args, **_arg1); end

    def register(**attributes); end
  end
end

module SolidQueue::Process::GeneratedAssociationMethods
  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#32
  def build_supervisor(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/collection_association.rb#62
  def claimed_execution_ids; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/collection_association.rb#72
  def claimed_execution_ids=(ids); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def claimed_executions; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def claimed_executions=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#36
  def create_supervisor(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#40
  def create_supervisor!(*args, &block); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/collection_association.rb#62
  def fork_ids; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/collection_association.rb#72
  def fork_ids=(ids); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def forks; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def forks=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#19
  def reload_supervisor; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/singular_association.rb#23
  def reset_supervisor; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#103
  def supervisor; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/association.rb#111
  def supervisor=(value); end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#145
  def supervisor_changed?; end

  # source://activerecord/7.1.2/lib/active_record/associations/builder/belongs_to.rb#149
  def supervisor_previously_changed?; end
end

module SolidQueue::Process::GeneratedAttributeMethods; end

module SolidQueue::Process::Prunable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Process::Prunable::ClassMethods
end

module SolidQueue::Process::Prunable::ClassMethods
  def prune; end
end

# source://solid_queue//lib/solid_queue/processes/supervised.rb#3
module SolidQueue::Processes; end

# source://solid_queue//lib/solid_queue/processes/base.rb#5
class SolidQueue::Processes::Base
  include ::ActiveSupport::Callbacks
  include ::SolidQueue::Processes::Procline
  include ::SolidQueue::Processes::Interruptible
  include ::SolidQueue::Processes::Registrable
  include ::SolidQueue::AppExecutor
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#963
  def _boot_callbacks; end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#951
  def _run_boot_callbacks(&block); end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#951
  def _run_shutdown_callbacks(&block); end

  # source://activesupport/7.1.2/lib/active_support/callbacks.rb#963
  def _shutdown_callbacks; end

  private

  # source://solid_queue//lib/solid_queue/processes/base.rb#16
  def boot; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#22
  def initial_jitter; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#12
  def observe_initial_delay; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#19
  def shutdown; end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#955
    def _boot_callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#959
    def _boot_callbacks=(value); end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#955
    def _shutdown_callbacks; end

    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#959
    def _shutdown_callbacks=(value); end
  end
end

# source://solid_queue//lib/solid_queue/processes/signals.rb#4
class SolidQueue::Processes::GracefulTerminationRequested < ::Interrupt; end

# source://solid_queue//lib/solid_queue/processes/signals.rb#5
class SolidQueue::Processes::ImmediateTerminationRequested < ::Interrupt; end

# source://solid_queue//lib/solid_queue/processes/interruptible.rb#4
module SolidQueue::Processes::Interruptible
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#5
  def wake_up; end

  private

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#32
  def create_self_pipe; end

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#12
  def interrupt; end

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#20
  def interruptible_sleep(time); end

  # Self-pipe for signal-handling (http://cr.yp.to/docs/selfpipe.html)
  #
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#28
  def self_pipe; end
end

# source://solid_queue//lib/solid_queue/processes/interruptible.rb#10
SolidQueue::Processes::Interruptible::SELF_PIPE_BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://solid_queue//lib/solid_queue/processes/pidfile.rb#4
class SolidQueue::Processes::Pidfile
  # @return [Pidfile] a new instance of Pidfile
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#5
  def initialize(path); end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#16
  def delete; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#10
  def setup; end

  private

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#54
  def already_running!; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#23
  def check_status; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#50
  def delete_file; end

  # Returns the value of attribute path.
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#21
  def path; end

  # Returns the value of attribute pid.
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#21
  def pid; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#46
  def set_at_exit_hook; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#39
  def write_file; end
end

# source://solid_queue//lib/solid_queue/processes/poller.rb#4
module SolidQueue::Processes::Poller
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/processes/poller.rb#20
  def metadata; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#12
  def with_polling_volume; end
end

# source://solid_queue//lib/solid_queue/processes/procline.rb#4
module SolidQueue::Processes::Procline
  # Sets the procline ($0)
  # solid-queue-supervisor(0.1.0): <string>
  #
  # source://solid_queue//lib/solid_queue/processes/procline.rb#7
  def procline(string); end
end

# source://solid_queue//lib/solid_queue/processes/registrable.rb#4
module SolidQueue::Processes::Registrable
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#15
  def inspect; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#15
  def to_s; end

  private

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#32
  def deregister; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#49
  def heartbeat; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#57
  def hostname; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#53
  def kind; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#40
  def launch_heartbeat; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#65
  def metadata; end

  # Returns the value of attribute process.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#21
  def process; end

  # Sets the attribute process
  #
  # @param value the value to set the attribute process to.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#21
  def process=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#61
  def process_pid; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#23
  def register; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#36
  def registered?; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#45
  def stop_heartbeat; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#4
module SolidQueue::Processes::Runnable
  include ::SolidQueue::Processes::Supervised

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#7
  def start; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#16
  def stop; end

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#8
  def supervisor; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#69
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#30
  def boot; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#43
  def do_start_loop; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#65
  def finished?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#26
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#22
  def mode=(_arg0); end

  # @raise [NotImplementedError]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#57
  def run; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#73
  def running_inline?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#53
  def shutting_down?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#35
  def start_loop; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#61
  def stopping?; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#24
SolidQueue::Processes::Runnable::DEFAULT_MODE = T.let(T.unsafe(nil), Symbol)

# source://solid_queue//lib/solid_queue/processes/signals.rb#7
module SolidQueue::Processes::Signals
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/processes/signals.rb#34
  def handle_signal(signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#28
  def process_signal_queue; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#13
  def register_signal_handlers; end

  # @raise [GracefulTerminationRequested]
  #
  # source://solid_queue//lib/solid_queue/processes/signals.rb#45
  def request_graceful_termination; end

  # @raise [ImmediateTerminationRequested]
  #
  # source://solid_queue//lib/solid_queue/processes/signals.rb#49
  def request_immediate_termination; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#22
  def restore_default_signal_handlers; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#59
  def signal_process(pid, signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#53
  def signal_processes(pids, signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#65
  def signal_queue; end
end

# source://solid_queue//lib/solid_queue/processes/signals.rb#11
SolidQueue::Processes::Signals::SIGNALS = T.let(T.unsafe(nil), Array)

# source://solid_queue//lib/solid_queue/processes/supervised.rb#4
module SolidQueue::Processes::Supervised
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#11
  def supervised_by(process); end

  private

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#25
  def register_signal_handlers; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#21
  def supervised?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#17
  def supervisor_went_away?; end
end

class SolidQueue::Queue
  def initialize(name); end

  def ==(queue); end
  def clear; end
  def eql?(queue); end
  def hash; end
  def name; end
  def name=(_arg0); end
  def pause; end
  def paused?; end
  def resume; end
  def size; end

  class << self
    def all; end
    def find_by_name(name); end
  end
end

class SolidQueue::QueueSelector
  def initialize(queue_list, relation); end

  def raw_queues; end
  def relation; end
  def scoped_relations; end

  private

  def all?; end
  def all_queues; end
  def eligible_queues; end
  def exact_names; end
  def include_all_queues?; end
  def none?; end
  def paused_queues; end
  def prefixed_names; end
  def prefixes; end
  def queue_names; end
end

class SolidQueue::ReadyExecution < ::SolidQueue::Execution
  include ::SolidQueue::ReadyExecution::GeneratedAttributeMethods
  include ::SolidQueue::ReadyExecution::GeneratedAssociationMethods

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    def claim(queue_list, limit, process_id); end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def queued_as(*args, **_arg1); end

    private

    def lock_candidates(job_ids, process_id); end
    def select_and_lock(queue_relation, process_id, limit); end
    def select_candidates(queue_relation, limit); end
  end
end

module SolidQueue::ReadyExecution::GeneratedAssociationMethods; end
module SolidQueue::ReadyExecution::GeneratedAttributeMethods; end

class SolidQueue::Record < ::ActiveRecord::Base
  include ::SolidQueue::Record::GeneratedAttributeMethods
  include ::SolidQueue::Record::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    def lock(*_arg0, **_arg1, &_arg2); end
  end
end

module SolidQueue::Record::GeneratedAssociationMethods; end
module SolidQueue::Record::GeneratedAttributeMethods; end

class SolidQueue::ScheduledExecution < ::SolidQueue::Execution
  include ::SolidQueue::ScheduledExecution::GeneratedAttributeMethods
  include ::SolidQueue::ScheduledExecution::GeneratedAssociationMethods

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    def dispatch_next_batch(batch_size); end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def due(*args, **_arg1); end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def next_batch(*args, **_arg1); end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end

    private

    def dispatch_at_once(jobs); end
    def dispatch_batch(job_ids); end
    def dispatch_one_by_one(jobs); end
    def dispatched_and_blocked(job_ids); end
    def dispatched_and_ready(job_ids); end
    def ready_rows_from_batch(jobs); end
    def successfully_dispatched(job_ids); end
  end
end

module SolidQueue::ScheduledExecution::GeneratedAssociationMethods; end
module SolidQueue::ScheduledExecution::GeneratedAttributeMethods; end

class SolidQueue::Semaphore < ::SolidQueue::Record
  include ::SolidQueue::Semaphore::GeneratedAttributeMethods
  include ::SolidQueue::Semaphore::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def available(*args, **_arg1); end

    # source://activerecord/7.1.2/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.2/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def signal(job); end
    def wait(job); end
  end
end

module SolidQueue::Semaphore::GeneratedAssociationMethods; end
module SolidQueue::Semaphore::GeneratedAttributeMethods; end

class SolidQueue::Semaphore::Proxy
  def initialize(job, proxied_class); end

  def signal; end
  def wait; end

  private

  def attempt_creation; end
  def attempt_decrement; end
  def attempt_increment; end
  def expires_at; end
  def job; end
  def key; end
  def limit; end
  def proxied_class; end
end

# source://solid_queue//lib/solid_queue/supervisor.rb#4
class SolidQueue::Supervisor < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Signals

  # @return [Supervisor] a new instance of Supervisor
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#18
  def initialize(*configured_processes); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#23
  def start; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#158
  def all_forks_terminated?; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#38
  def boot; end

  # Returns the value of attribute configured_processes.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#36
  def configured_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#109
  def delete_pidfile; end

  # Returns the value of attribute forks.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#36
  def forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#81
  def graceful_termination; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#92
  def immediate_termination; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#66
  def launch_process_prune; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#178
  def monotonic_time_now; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#113
  def prune_dead_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#101
  def quit_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#129
  def reap_and_replace_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#138
  def reap_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#149
  def replace_fork(pid, status); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#60
  def setup_pidfile; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#75
  def shutdown; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#119
  def start_fork(configured_process); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#71
  def start_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#105
  def stop_process_prune; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#44
  def supervise; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#56
  def sync_std_streams; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#97
  def term_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#162
  def wait_until(timeout, condition, &block); end

  class << self
    # source://activesupport/7.1.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://solid_queue//lib/solid_queue/supervisor.rb#10
    def start(mode: T.unsafe(nil), load_configuration_from: T.unsafe(nil)); end
  end
end

# source://solid_queue//lib/solid_queue/version.rb#2
SolidQueue::VERSION = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/worker.rb#4
class SolidQueue::Worker < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Poller
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable

  # @return [Worker] a new instance of Worker
  #
  # source://solid_queue//lib/solid_queue/worker.rb#9
  def initialize(**options); end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#8
  def polling_interval; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#8
  def polling_interval=(_arg0); end

  # Returns the value of attribute pool.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def pool=(_arg0); end

  # Returns the value of attribute queues.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def queues; end

  # Sets the attribute queues
  #
  # @param value the value to set the attribute queues to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def queues=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/worker.rb#46
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/worker.rb#50
  def metadata; end

  # source://solid_queue//lib/solid_queue/worker.rb#33
  def poll; end

  # source://solid_queue//lib/solid_queue/worker.rb#18
  def run; end

  # source://solid_queue//lib/solid_queue/worker.rb#39
  def shutdown; end
end
